package csu.agent.fb;

import java.awt.Point;
import java.awt.geom.Ellipse2D;
import java.util.ArrayList;
import java.util.Collection;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import csu.LaunchAgents;
import csu.Viewer.layers.CSU_PartitionLayer;
import csu.agent.PlatoonAgent;
import csu.agent.fb.tools.FbUtilities;
import csu.model.AdvancedWorldModel;
import csu.model.AgentConstants;
import csu.model.object.CSUBuilding;
import csu.model.object.CSURoad;
import rescuecore2.misc.Pair;
import rescuecore2.standard.entities.Building;
import rescuecore2.standard.entities.FireBrigade;
import rescuecore2.standard.entities.Road;
import rescuecore2.standard.entities.StandardEntity;
import rescuecore2.standard.entities.StandardEntityURN;
import rescuecore2.standard.messages.StandardMessageURN;
import rescuecore2.worldmodel.EntityID;

public abstract class AbstractFireBrigadeAgent extends PlatoonAgent<FireBrigade> {
	/**
	 * The clusters of map buildings generated by Kmeans-Plus-Plus.
	 */
	protected ArrayList<csu.agent.fb.cluster.Cluster> searchClusters;
	protected Map<Integer, Integer> waterHistory;
	/**we try not to make lastFire and thisFire become null*/
	/**lastFire is the last recent extinguish target before this time*/
	protected CSUBuilding lastFire;
	/**thisFire is the target we going to extinguish in this time*/
	protected CSUBuilding thisFire;
	protected int preWater = 0;
	protected int currentWater = 0;
	/**
	 * The index of the cluster which this agent assigned to at the initializing time.
	 */
	protected int assignedSearchClusterIndex;
	
	public EntityID extinguishTarget = null;
	public int waterPower = 0;
	
	public void extinguish(EntityID target, int water) throws  ActionCommandException {
		this.extinguishTarget = target;
		this.waterPower = water;
		sendExtinguish(time, target, water);
		throw new ActionCommandException(StandardMessageURN.AK_EXTINGUISH);
	}

	public void extinguish(Building target, int water) throws  ActionCommandException {
		extinguish(target.getID(), water);
	}

	public void extinguish(EntityID target) throws  ActionCommandException {
		extinguish(target, world.getConfig().maxPower);
	}

	public void extinguish(Building target) throws  ActionCommandException {
		extinguish(target.getID());
	}

	public boolean isExtinguishable(FireBrigade fb, Building building) {
		Pair<Integer, Integer> position = fb.getLocation(world);
		final int r = world.getConfig().extinguishableDistance;
		java.awt.geom.Area range = new java.awt.geom.Area(new Ellipse2D.Double(
				position.first() - r, position.second() - r,
				r * 2, r * 2));
		range.intersect(new java.awt.geom.Area(building.getShape()));
		return !range.isEmpty();
	}
	
	public ArrayList<Building> extinguishableBuilding(AdvancedWorldModel world, List<Building> targets){
		ArrayList<Building> inRange = new ArrayList<Building>();
		for (Building building : targets){
			if (world.getDistance(building, me()) < world.getConfig().extinguishableDistance)
				if (building.isFierynessDefined() && building.isOnFire())
					inRange.add(building);
		}
		return inRange;
	}
	
	public ArrayList<Building> visibleFiredBuilding(AdvancedWorldModel world, List<Building> targets) {
		ArrayList<Building> inRange = new ArrayList<Building>();
		
		for (Building building : targets) {
			if (world.getDistance(building, me()) < world.getConfig().viewDistance){
				if (building.isFierynessDefined() && building.isOnFire()) {
					inRange.add(building);
				}
			}
		}
		return inRange;
	}
	
	public boolean isExtinguishable(Building building) {
		return isExtinguishable(me(), building);
	}

	public boolean isEXTQuick(FireBrigade fb, Building fireBuilding) {
		double distance = 25000;
		if(! (world.getDistance(fb, fireBuilding) < distance))
			return false;
		if(! isExtinguishable(fb, fireBuilding))
			return false;
		int area = fireBuilding.getGroundArea();
		int neededWater = FbUtilities.waterNeededToExtinguish(world.getCsuBuilding(fireBuilding));
		if(area > 2300 || neededWater / world.getConfig().maxPower > 3)
			return false;
		return true;
	} 
	@Override
	protected EnumSet<StandardEntityURN> getRequestedEntityURNsEnum() {
		return EnumSet.of(StandardEntityURN.FIRE_BRIGADE);
	}
	
	protected void getSearchClusters() {
		Collection<StandardEntity> allFbs = 
				world.getEntitiesOfType(StandardEntityURN.FIRE_BRIGADE);
		Collection<StandardEntity> areas = world.getEntitiesOfType(AgentConstants.AREAS);
		if (LaunchAgents.SHOULD_PRECOMPUTE) {
			String fileName = "precompute/fbClusters";
			java.io.File file = new java.io.File(fileName);
			if (file.exists()) {
				System.out.println("File exists!");
				searchClusters = csu.agent.fb.cluster.Clustering.readFromFile(fileName, world);
			} else {
				try {
					file.createNewFile();
				} catch (java.io.IOException e) {
					e.printStackTrace();
				}
				System.out.println("File not exists!");
				
				searchClusters = csu.agent.fb.
						cluster.Clustering.KMeansPlusPlus(allFbs.size(), areas, world);
				csu.agent.fb.cluster.Clustering.writeToFile(searchClusters, fileName);
			}
		} else {
			searchClusters = csu.agent.fb.
					cluster.Clustering.KMeansPlusPlus(allFbs.size(), areas, world);
		}
		
		for (csu.agent.fb.cluster.Cluster next : searchClusters) {
			next.classifyPoints();
		}
		
		if (AgentConstants.LAUNCH_VIEWER) {
			if (CSU_PartitionLayer.FB_CLUSTERS.isEmpty()) {
				CSU_PartitionLayer.FB_CLUSTERS.addAll(searchClusters);
			}
		}
		
		csu.agent.fb.cluster.Clustering.assignAgentsToClusters(allFbs, searchClusters, world);
		assignedSearchClusterIndex = csu.agent.fb.
				cluster.Clustering.getClusterIndexAgentBelong(getID(), searchClusters);
		
		System.out.println("my position: " + me().getPosition());
		System.out.println("my cluster index is: " + assignedSearchClusterIndex);
	}
	
/* -------------------------------------------------------------------------------------------------------- */	

	@Override
	protected void initUnlookuped() {
		csu.agent.fb.cluster.Cluster cluster = searchClusters.get(assignedSearchClusterIndex);
		
		unlookupedBuildings = new HashSet<>(cluster.getCriticalAreas().size() * 2);
		
		for (Iterator<EntityID> itor = cluster.getCriticalAreas().iterator(); itor.hasNext(); ) {
			EntityID next = itor.next();
			if (world.getCriticalArea().isCriticalArea(next))
				unlookupedBuildings.add(next);
			else
				itor.remove();
		}
	}
	
	@Override
	protected void initUnentered() {
		csu.agent.fb.cluster.Cluster cluster = searchClusters.get(assignedSearchClusterIndex);
		
		unenteredBuildings = new HashSet<>(cluster.getBuildingAreas().size() * 2);
		unenteredBuildings.addAll(cluster.getBuildingAreas());
	}

	@Override
	protected void lookupSearchBuildings() throws ActionCommandException {
		if (unlookupedBuildings == null || unlookupedBuildings.isEmpty()) {
		///	if(!isHovering())
				initUnlookuped();  ///a kind of strategy? look up again and again?
		//	else ///marking/
		///		return;
		}
		unlookupedBuildings.removeAll(someoneVisitedArea);
		
		unlookupedBuildings.removeAll(changed.getChangedEntities());
//		///test
//		for (EntityID next : getChanged()) {
//			StandardEntity entity = world.getEntity(next);
//			if (!(entity instanceof Road))
//				continue;
//		    CSURoad road = world.getCsuRoad(next);
//			
//			if (road.isEntrance()) {
//				for (Building build : world.getEntrance().getBuilding(road.getSelfRoad())) {
//					unlookupedBuildings.remove(build.getID());
//				}
//			}
//		}
		///
		if (unlookupedBuildings.isEmpty()) {
			
			if(AgentConstants.FB)
				System.out.println(world.getTime() +  ", "  + world.me + ", " + "no  critical area to search" +
						", lookupSearchBuildings1");
			return;
		}
		
		Set<StandardEntity> dest = new HashSet<StandardEntity>(unlookupedBuildings.size());
		for (EntityID id : unlookupedBuildings) {
			dest.add(world.getEntity(id));
		}
		
		Point selfL = new Point(me().getX(), me().getY());
		List<EntityID> path = router.getMultiAStar(location(), dest, router.getNormalCostFunction(), selfL);
		///remove buildings just near the fire brigade
		while (path.size() == 1) {  ///test
			unlookupedBuildings.remove(path.get(0));
			dest.remove(world.getEntity(path.get(0)));
			if (dest.isEmpty()) { 
								
				if(AgentConstants.FB)
					System.out.println(world.getTime() +  ", "  + world.me + ", " + "no  critical area to search" +
							", lookupSearchBuildings2");
				
				return; 
			}
			path = router.getMultiAStar(location(), dest, router.getNormalCostFunction(), selfL);
		}
		
		if (path != null) {
			
			if (AgentConstants.FB) {
				String str = null;
				for (EntityID next : path) {
					if (str == null) 
						str = next.getValue() + "";
					else
						str = str + ", " + next.getValue();
				}
			
				EntityID destCri = path.get(path.size() - 1);
				
				System.out.println(world.getTime() +  ", "  + world.me + ", " + "lookup critical area" +
					 destCri + ", path = [" + str + "] "+ ", lookupSearchBuildings");
			}	
			move(path);
		}
	}
	
	@Override
	protected void enterSearchBuildings() throws ActionCommandException {
		if (unenteredBuildings == null || unenteredBuildings.isEmpty()) {
		///	if(!isHovering())  ///test. search by road rather than building, okay
				initUnentered();
		///	else ///marking
		///		return;
		}        ///    searchedBuildings can only be added when the agent.getPosition instance of building, the road not, so will walk back and forth
		unenteredBuildings.removeAll(someoneVisitedArea);
		for (Iterator<EntityID> it = unenteredBuildings.iterator(); it.hasNext();) {
			EntityID id = it.next();
			StandardEntity se = world.getEntity(id);
			if (se instanceof Building) {
				Building building = (Building) se;
				if (world.getCollapsedBuildings().contains(building) 
						|| world.getBurningBuildings().contains(building)) {
					it.remove(); /// won't current modify exception ?
				} else if (building.isTemperatureDefined() && building.getTemperature() > 25) {
					it.remove();
				}
			}
		}
		
		for (EntityID next : getChanged()) {
			StandardEntity entity = world.getEntity(next);
			if (!(entity instanceof Road))
				continue;
			CSURoad road = world.getCsuRoad(next);

			if (road.isEntrance()) {
				for (Building build : world.getEntrance().getBuilding(road.getSelfRoad())) {
					unenteredBuildings.remove(build.getID());
				}
			}
		}
		
		if (!unenteredBuildings.isEmpty()) {
			Set<StandardEntity> dest = new HashSet<StandardEntity>(unenteredBuildings.size());
			for (EntityID id : unenteredBuildings) {
				dest.add(world.getEntity(id));
			}
			
			dest.remove(location().getID());
			
//			if(AgentConstants.FB)
//				System.out.println(world.getTime() +  ", "  + world.me + ", " + dest + ", enter search building" +
//						", enterSearchBuildings");
//			
			move(dest);
		}
	}
	
	public CSUBuilding getLastFire() {
		return this.lastFire;
	}
	public void setLastFire(CSUBuilding build) {
		this.lastFire = build;
	}
	public CSUBuilding getThisFire() {
		return this.thisFire;
	}
	public void setThisFire(CSUBuilding build) {
		this.thisFire = build;
	}
}
